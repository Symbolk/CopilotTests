[
    {
        "file_path": "slib_runnable/test_10.py",
        "name": "_encode_endpoint_path",
        "docstring": "base64 encode an backup path for cross mounting support",
        "lineno": 22,
        "code": "def _encode_endpoint_path(backup_endpoint):\n        \"\"\"base64 encode an backup path for cross mounting support\"\"\"\n        return base64.b64encode(\n            str.encode(urlparse(backup_endpoint).path)).decode()\n",
        "test_name": "test__encode_endpoint_path",
        "test_lineno": 28,
        "test_code": "def test__encode_endpoint_path():\n    \"\"\"Check the correctness of _encode_endpoint_path\n    \"\"\"\n    assert _encode_endpoint_path('/backup/path') == 'L2JhY2t1cC9wYXRo'\n    assert _encode_endpoint_path('/backup/path/') == 'L2JhY2t1cC9wYXRoLw=='\n    assert _encode_endpoint_path('/backup/path/with/slash') == 'L2JhY2t1cC9wYXRoL3dpdGgvc2xhc2g='",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_24.py",
        "name": "get_repo_archive",
        "docstring": "Given an url and a destination path, retrieve and extract .tar.gz archive\nwhich contains 'desc' file for each package.\nEach .tar.gz archive corresponds to an Arch Linux repo ('core', 'extra', 'community').\n\nArgs:\n    url: url of the .tar.gz archive to download\n    destination_path: the path on disk where to extract archive\n\nReturns:\n    a directory Path where the archive has been extracted to.",
        "lineno": 18,
        "code": "def get_repo_archive(url: str, destination_path: Path) -> Path:\n    \"\"\"\n    Given an url and a destination path, retrieve and extract .tar.gz archive\n    which contains 'desc' file for each package.\n    Each .tar.gz archive corresponds to an Arch Linux repo ('core', 'extra', 'community').\n\n    Args:\n        url: url of the .tar.gz archive to download\n        destination_path: the path on disk where to extract archive\n\n    Returns:\n        a directory Path where the archive has been extracted to.\n    \"\"\"\n    res = requests.get(url)\n    destination_path.parent.mkdir(parents=True, exist_ok=True)\n    destination_path.write_bytes(res.content)\n\n    extract_to = Path(str(destination_path).split(\".tar.gz\")[0])\n    tar = tarfile.open(destination_path)\n    tar.extractall(path=extract_to)\n    tar.close()\n\n    return extract_to\n",
        "test_name": "test_get_repo_archive",
        "test_lineno": 42,
        "test_code": "def test_get_repo_archive():\n    \"\"\"Check the correctness of get_repo_archive\n    \"\"\"\n    assert get_repo_archive('https://dl.bintray.com/sherpa/sherpa-repo/sherpa-repo-core-2020-01-01.tar.gz', Path('/tmp/sherpa-repo-core-2020-01-01.tar.gz')) == Path('/tmp/sherpa-repo-core-2020-01-01')",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_20.py",
        "name": "os_is_mac",
        "docstring": "Checks if the os is macOS\n\n:return: True is macOS\n:rtype: bool",
        "lineno": 17,
        "code": "def os_is_mac():\n    \"\"\"\n    Checks if the os is macOS\n\n    :return: True is macOS\n    :rtype: bool\n    \"\"\"\n    return platform.system() == \"Darwin\"\n",
        "test_name": "test_os_is_mac",
        "test_lineno": 31,
        "test_code": "def test_os_is_mac():\n    \"\"\"Check the correctness of os_is_mac\n    \"\"\"\n    assert os_is_mac() == (platform.system()==\"Darwin\")",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_14.py",
        "name": "regex_dict",
        "docstring": "Convert *.cpp keys to regex keys\n\nGiven a dict where the keys are all filenames with wildcards, convert only\nthe keys into equivalent regexes and leave the values intact.\n\nExample:\n\nrules = {\n    '*.cpp':\n        {'a': 'arf', 'b': 'bark', 'c': 'coo'},\n    '*.h':\n        {'h': 'help'}\n}\nregex_keys = regex_dict(rules)\n\nArgs:\n    item: dict to convert\nReturns:\n    dict with keys converted to regexes",
        "lineno": 21,
        "code": "def regex_dict(item):\n    \"\"\"\n    Convert *.cpp keys to regex keys\n\n    Given a dict where the keys are all filenames with wildcards, convert only\n    the keys into equivalent regexes and leave the values intact.\n\n    Example:\n\n    rules = {\n        '*.cpp':\n            {'a': 'arf', 'b': 'bark', 'c': 'coo'},\n        '*.h':\n            {'h': 'help'}\n    }\n    regex_keys = regex_dict(rules)\n\n    Args:\n        item: dict to convert\n    Returns:\n        dict with keys converted to regexes\n    \"\"\"\n\n    output = {}\n    for key in item:\n        output[re.compile(fnmatch.translate(key)).match] = item[key]\n    return output\n",
        "test_name": "test_regex_dict",
        "test_lineno": 49,
        "test_code": "def test_regex_dict():\n    \"\"\"Check the correctness of regex_dict\n    \"\"\"\n    assert regex_dict({'*.cpp': {'a': 'arf', 'b': 'bark', 'c': 'coo'}}) == {re.compile(fnmatch.translate('*.cpp')).match: {'a': 'arf','b': 'bark','c': 'coo'}}\n    assert regex_dict({'*.h': {'h': 'help'}}) == {re.compile(fnmatch.translate('*.h')).match: {'h': 'help'}}\n    assert regex_dict({'*.cpp': {'a': 'arf', 'b': 'bark', 'c': 'coo'}, '*.h': {'h': 'help'}}) == {re.compile(fnmatch.translate('*.cpp')).match: {'a': 'arf','b': 'bark','c': 'coo'}, re.compile(fnmatch.translate('*.h')).match: {'h': 'help'}}",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_4.py",
        "name": "unquote",
        "docstring": "Remove quote from the given name.",
        "lineno": 21,
        "code": "def unquote(name):\n    \"\"\"Remove quote from the given name.\"\"\"\n    assert isinstance(name, bytes)\n\n    # This function just gives back the original text if it can decode it\n    def unquoted_char(match):\n        \"\"\"For each ;000 return the corresponding byte.\"\"\"\n        if len(match.group()) != 4:\n            return match.group\n        try:\n            return bytes([int(match.group()[1:])])\n        except ValueError:\n            return match.group\n\n    # Remove quote using regex\n    return re.sub(b\";[0-9]{3}\", unquoted_char, name, re.S)\n",
        "test_name": "test_unquote",
        "test_lineno": 40,
        "test_code": "def test_unquote():\n    \"\"\"Check the correctness of unquote\n    \"\"\"\n    assert unquote(b\"Hello\") == b\"Hello\"\n    assert unquote(b\"Hello;000\") == b'Hello\\x00'\n    assert unquote(b\"Hello;001\") == b'Hello\\x01'\n    assert unquote(b\"Hello;002\") == b'Hello\\x02'\n    assert unquote(b\"Hello;003\") == b'Hello\\x03'\n    assert unquote(b\"Hello;004\") == b'Hello\\x04'",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_21.py",
        "name": "split",
        "docstring": "Multi-platform variant of shlex.split() for command-line splitting.\nFor use with subprocess, for argv injection etc. Using fast REGEX.\n\nplatform: 'this' = auto from current platform;\n          1 = POSIX;\n          0 = Windows/CMD\n          (other values reserved)",
        "lineno": 6,
        "code": "def split(s, platform='this'):\n    \"\"\"Multi-platform variant of shlex.split() for command-line splitting.\n    For use with subprocess, for argv injection etc. Using fast REGEX.\n\n    platform: 'this' = auto from current platform;\n              1 = POSIX;\n              0 = Windows/CMD\n              (other values reserved)\n    \"\"\"\n    if platform == 'this':\n        platform = (sys.platform != 'win32')\n    if platform == 1:\n        RE_CMD_LEX = r'''\"((?:\\\\[\"\\\\]|[^\"])*)\"|'([^']*)'|(\\\\.)|(&&?|\\|\\|?|\\d?\\>|[<])|([^\\s'\"\\\\&|<>]+)|(\\s+)|(.)'''\n    elif platform == 0:\n        RE_CMD_LEX = r'''\"((?:\"\"|\\\\[\"\\\\]|[^\"])*)\"?()|(\\\\\\\\(?=\\\\*\")|\\\\\")|(&&?|\\|\\|?|\\d?>|[<])|([^\\s\"&|<>]+)|(\\s+)|(.)'''\n    else:\n        raise AssertionError('unkown platform %r' % platform)\n\n    args = []\n    accu = None   # collects pieces of one arg\n    for qs, qss, esc, pipe, word, white, fail in re.findall(RE_CMD_LEX, s):\n        if word:\n            pass   # most frequent\n        elif esc:\n            word = esc[1]\n        elif white or pipe:\n            if accu is not None:\n                args.append(accu)\n            if pipe:\n                args.append(pipe)\n            accu = None\n            continue\n        elif fail:\n            raise ValueError(\"invalid or incomplete shell string\")\n        elif qs:\n            word = qs.replace('\\\\\"', '\"').replace('\\\\\\\\', '\\\\')\n            if platform == 0:\n                word = word.replace('\"\"', '\"')\n        else:\n            word = qss   # may be even empty; must be last\n\n        accu = (accu or '') + word\n\n    if accu is not None:\n        args.append(accu)\n\n    return args\n",
        "test_name": "test_split",
        "test_lineno": 56,
        "test_code": "def test_split():\n    \"\"\"Check the correctness of split\n    \"\"\"\n    assert split('\"a\" \"b\"') == ['a', 'b']\n    assert split('\"a\" \"b\"', platform=0) == ['a', 'b']\n    assert split('\"a\" \"b\"', platform=1) == ['a', 'b']\n    assert split('\"a\" \"b\"', platform='this') == ['a', 'b']\n    assert split('\"a\" \"b\"', platform=0) == ['a', 'b']",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_15.py",
        "name": "prepare_repository_from_archive",
        "docstring": "Given an existing archive_path, uncompress it.\nReturns a file repo url which can be used as origin url.\n\nThis does not deal with the case where the archive passed along does not exist.",
        "lineno": 14,
        "code": "def prepare_repository_from_archive(\n    archive_path: str,\n    filename: Optional[str] = None,\n    tmp_path: Union[PosixPath, str] = \"/tmp\",\n) -> str:\n    \"\"\"Given an existing archive_path, uncompress it.\n    Returns a file repo url which can be used as origin url.\n\n    This does not deal with the case where the archive passed along does not exist.\n    \"\"\"\n    if not isinstance(tmp_path, str):\n        tmp_path = str(tmp_path)\n    # uncompress folder/repositories/dump for the loader to ingest\n    subprocess.check_output([\"tar\", \"xf\", archive_path, \"-C\", tmp_path])\n    # build the origin url (or some derivative form)\n    _fname = filename if filename else os.path.basename(archive_path)\n    repo_url = f\"file://{tmp_path}/{_fname}\"\n    return repo_url\n",
        "test_name": "test_prepare_repository_from_archive",
        "test_lineno": 35,
        "test_code": "def test_prepare_repository_from_archive():\n    \"\"\"Check the correctness of prepare_repository_from_archive\n    \"\"\"\n    assert prepare_repository_from_archive(\"tests/data/repositories/dump.tar.gz\") == \"file:///tmp/dump\"",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_5.py",
        "name": "addignored",
        "docstring": "Use the git command to obtain the file names, turn it into a list, sort the list for only ignored files, return those files as a single string with each filename separated by a comma.",
        "lineno": 22,
        "code": "def addignored(ignored):\n    ''' Use the git command to obtain the file names, turn it into a list, sort the list for only ignored files, return those files as a single string with each filename separated by a comma.'''\n    fldr=subprocess.run([\"git\", \"-C\", ignored, \"status\", \"-s\", \"--ignored\"], capture_output=True, text=True).stdout.strip(\"\\n\")\n    x = fldr.splitlines()\n    sub = \"!\"\n    g = ([s for s in x if sub in s])\n    i = [elem.replace(sub, '') for elem in g]\n    t = \", \".join(i)\n    return t\n",
        "test_name": "test_addignored",
        "test_lineno": 35,
        "test_code": "def test_addignored():\n    \"\"\"Check the correctness of addignored\n    \"\"\"\n    assert addignored(\".\") == \" ../self_contained/.pytest_cache/,  .pytest_cache/\"\n",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_11.py",
        "name": "match",
        "docstring": "Check if the filename is a type that this module supports\n\nArgs:\n    filename: Filename to match\nReturns:\n    False if not a match, True if supported",
        "lineno": 27,
        "code": "def match(filename):\n    \"\"\"\n    Check if the filename is a type that this module supports\n\n    Args:\n        filename: Filename to match\n    Returns:\n        False if not a match, True if supported\n    \"\"\"\n\n    base_name = os.path.basename(filename)\n    base_name_lower = base_name.lower()\n    return base_name_lower == 'doxyfile'\n",
        "test_name": "test_match",
        "test_lineno": 42,
        "test_code": "def test_match():\n    \"\"\"Check the correctness of match\n    \"\"\"\n    assert match('doxyfile')\n    assert not match('doxygen.conf')\n    assert not match('doxygen.conf.dist')\n    assert not match('doxygen.conf.dist.dist')\n    assert not match('doxygen.conf.dist.dist.dist')\n    assert match('DOXyFile')\n    assert match('DOXyFILE')",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_1.py",
        "name": "parse_frequency",
        "docstring": "Given a frequency string with a number and a unit of time, return a corresponding\ndatetime.timedelta instance or None if the frequency is None or \"always\".\n\nFor instance, given \"3 weeks\", return datetime.timedelta(weeks=3)\n\nRaise ValueError if the given frequency cannot be parsed.",
        "lineno": 16,
        "code": "def parse_frequency(frequency):\n    '''\n    Given a frequency string with a number and a unit of time, return a corresponding\n    datetime.timedelta instance or None if the frequency is None or \"always\".\n\n    For instance, given \"3 weeks\", return datetime.timedelta(weeks=3)\n\n    Raise ValueError if the given frequency cannot be parsed.\n    '''\n    if not frequency:\n        return None\n\n    frequency = frequency.strip().lower()\n\n    if frequency == 'always':\n        return None\n\n    try:\n        number, time_unit = frequency.split(' ')\n        number = int(number)\n    except ValueError:\n        raise ValueError(f\"Could not parse consistency check frequency '{frequency}'\")\n\n    if not time_unit.endswith('s'):\n        time_unit += 's'\n\n    if time_unit == 'months':\n        number *= 4\n        time_unit = 'weeks'\n    elif time_unit == 'years':\n        number *= 365\n        time_unit = 'days'\n\n    try:\n        return datetime.timedelta(**{time_unit: number})\n    except TypeError:\n        raise ValueError(f\"Could not parse consistency check frequency '{frequency}'\")\n",
        "test_name": "test_parse_frequency",
        "test_lineno": 57,
        "test_code": "def test_parse_frequency():\n    \"\"\"Check the correctness of parse_frequency\n    \"\"\"\n    assert parse_frequency('1 day') == datetime.timedelta(days=1)\n    assert parse_frequency('1 week') == datetime.timedelta(weeks=1)\n    assert parse_frequency('1 month') == datetime.timedelta(weeks=4)\n    assert parse_frequency('1 year') == datetime.timedelta(days=365)\n    assert parse_frequency('1 day') == datetime.timedelta(days=1)\n    assert parse_frequency('10 day') == datetime.timedelta(days=10)",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_18.py",
        "name": "is_local",
        "docstring": "Checks if the host is the localhost\n\n:param host: The hostname or ip\n:return: True if the host is the localhost",
        "lineno": 19,
        "code": "def is_local(host):\n    \"\"\"\n    Checks if the host is the localhost\n\n    :param host: The hostname or ip\n    :return: True if the host is the localhost\n    \"\"\"\n    return host in [\"127.0.0.1\",\n                    \"localhost\",\n                    socket.gethostname(),\n                    # just in case socket.gethostname() does not work  we also try the following:\n                    platform.node(),\n                    socket.gethostbyaddr(socket.gethostname())[0]\n                    ]\n",
        "test_name": "test_is_local",
        "test_lineno": 35,
        "test_code": "def test_is_local():\n    \"\"\"Check the correctness of is_local\n    \"\"\"\n    assert is_local(' ') == False\n    assert is_local('   ') == False\n    assert is_local('127.0.0.1')   == True\n    assert is_local('localhost')   == True\n    assert is_local(' localhost ') == True\n    assert is_local(platform.node()) == True\n    assert is_local(socket.gethostbyaddr(socket.gethostname())[0]) == True\n    assert is_local(socket.gethostname()) == True\n",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_8.py",
        "name": "make_find_paths",
        "docstring": "Given a sequence of path fragments or patterns as passed to `--find`, transform all path\nfragments into glob patterns. Pass through existing patterns untouched.\n\nFor example, given find_paths of:\n\n  ['foo.txt', 'pp:root/somedir']\n\n... transform that into:\n\n  ['sh:**/*foo.txt*/**', 'pp:root/somedir']",
        "lineno": 12,
        "code": "def make_find_paths(find_paths):\n    '''\n    Given a sequence of path fragments or patterns as passed to `--find`, transform all path\n    fragments into glob patterns. Pass through existing patterns untouched.\n\n    For example, given find_paths of:\n\n      ['foo.txt', 'pp:root/somedir']\n\n    ... transform that into:\n\n      ['sh:**/*foo.txt*/**', 'pp:root/somedir']\n    '''\n\n    return tuple(\n        find_path\n        if re.compile(r'([-!+RrPp] )|(\\w\\w:)').match(find_path)\n        else f'sh:**/*{find_path}*/**'\n        for find_path in find_paths\n    )\n",
        "test_name": "test_make_find_paths",
        "test_lineno": 35,
        "test_code": "def test_make_find_paths():\n    \"\"\"Check the correctness of make_find_paths\n    \"\"\"\n    assert make_find_paths(('foo.txt', 'pp:root/somedir')) == ('sh:**/*foo.txt*/**', 'pp:root/somedir')\n    assert make_find_paths(('foo.txt', 'pp:root/somedir', '-R')) == ('sh:**/*foo.txt*/**', 'pp:root/somedir', 'sh:**/*-R*/**')\n    assert make_find_paths(('foo.txt', 'pp:root/somedir', '-R', '-r')) == ('sh:**/*foo.txt*/**', 'pp:root/somedir', 'sh:**/*-R*/**', 'sh:**/*-r*/**')\n    assert make_find_paths(('foo.txt', 'pp:root/somedir', '-R', '-r', '-P')) == ('sh:**/*foo.txt*/**', 'pp:root/somedir', 'sh:**/*-R*/**', 'sh:**/*-r*/**', 'sh:**/*-P*/**')\n    assert make_find_paths(('foo.txt', 'pp:root/somedir', '-R', '-r', '-P', '-p')) == ('sh:**/*foo.txt*/**', 'pp:root/somedir', 'sh:**/*-R*/**', 'sh:**/*-r*/**', 'sh:**/*-P*/**', 'sh:**/*-p*/**')",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_19.py",
        "name": "is_gitbash",
        "docstring": "returns True if you run in a Windows gitbash\n\n:return: True if gitbash",
        "lineno": 21,
        "code": "def is_gitbash():\n    \"\"\"\n    returns True if you run in a Windows gitbash\n\n    :return: True if gitbash\n    \"\"\"\n    try:\n        exepath = os.environ['EXEPATH']\n        return \"Git\" in exepath\n    except:\n        return False\n",
        "test_name": "test_is_gitbash",
        "test_lineno": 37,
        "test_code": "def test_is_gitbash():\n    \"\"\"Check the correctness of is_gitbash\n    \"\"\"\n    assert is_gitbash() == False",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_9.py",
        "name": "write_configuration",
        "docstring": "Given a target config filename and rendered config YAML, write it out to file. Create any\ncontaining directories as needed. But if the file already exists and overwrite is False,\nabort before writing anything.",
        "lineno": 11,
        "code": "def write_configuration(config_filename, rendered_config, mode=0o600, overwrite=False):\n    '''\n    Given a target config filename and rendered config YAML, write it out to file. Create any\n    containing directories as needed. But if the file already exists and overwrite is False,\n    abort before writing anything.\n    '''\n    if not overwrite and os.path.exists(config_filename):\n        return FileExistsError\n        # raise FileExistsError(\n        #     '{} already exists. Aborting. Use --overwrite to replace the file.'.format(\n        #         config_filename\n        #     )\n        # )\n\n    try:\n        os.makedirs(os.path.dirname(config_filename), mode=0o700)\n    except (FileExistsError, FileNotFoundError):\n        pass\n\n    with open(config_filename, 'w') as config_file:\n        config_file.write(rendered_config)\n\n    os.chmod(config_filename, mode)\n    return rendered_config\n",
        "test_name": "test_write_configuration",
        "test_lineno": 37,
        "test_code": "def test_write_configuration():\n    \"\"\"Check the correctness of write_configuration\n    \"\"\"\n    assert write_configuration('test.yaml', 'test', overwrite=True) == 'test'\n    assert write_configuration('test.yaml', 'test', overwrite=False) == FileExistsError\n    assert write_configuration('test.yaml', 'hhhhh', overwrite=True) == 'hhhhh'\n    assert write_configuration('test.yaml', 'hhhhh', overwrite=False) == FileExistsError",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_22.py",
        "name": "oneline",
        "docstring": "converts a script to one line command.\nTHis is useful to run a single ssh command and pass a one line script.\n\n:param script:\n:return:",
        "lineno": 63,
        "code": "def oneline(script, seperator=\" && \"):\n    \"\"\"\n    converts a script to one line command.\n    THis is useful to run a single ssh command and pass a one line script.\n\n    :param script:\n    :return:\n    \"\"\"\n    return seperator.join(textwrap.dedent(script).strip().splitlines())\n",
        "test_name": "test_oneline",
        "test_lineno": 76,
        "test_code": "def test_oneline():\n    \"\"\"Check the correctness of oneline\n    \"\"\"\n    assert oneline(\"hello\") == \"hello\"\n    assert oneline(\"hello\\nworld\") == \"hello && world\"\n    assert oneline(\"hello\\nworld\\n\") == \"hello && world\"\n    assert oneline(\"hello\\nworld\\n\", \";\") == \"hello;world\"\n    assert oneline(\"hello\\nworld\\n\", \"&&\") == \"hello&&world\"\n    assert oneline(\"hello\\nworld\\n\", \"||\") == \"hello||world\"\n    assert oneline(\"hello\\nworld\\n\", \";|\") == \"hello;|world\"",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_16.py",
        "name": "subprocess_run_helper",
        "docstring": "Run a function in a sub-process.\n\nParameters\n----------\nfunc : function\n    The function to be run.  It must be in a module that is importable.\n*args : str\n    Any additional command line arguments to be passed in\n    the first argument to ``subprocess.run``.\nextra_env : dict[str, str]\n    Any additional environment variables to be set for the subprocess.",
        "lineno": 53,
        "code": "def subprocess_run_helper(func, *args, timeout, extra_env=None):\n    \"\"\"\n    Run a function in a sub-process.\n\n    Parameters\n    ----------\n    func : function\n        The function to be run.  It must be in a module that is importable.\n    *args : str\n        Any additional command line arguments to be passed in\n        the first argument to ``subprocess.run``.\n    extra_env : dict[str, str]\n        Any additional environment variables to be set for the subprocess.\n    \"\"\"\n    target = func.__name__\n    module = func.__module__\n    proc = subprocess.run(\n        [sys.executable,\n         \"-c\",\n         f\"from {module} import {target}; {target}()\",\n         *args],\n        env={**os.environ, \"SOURCE_DATE_EPOCH\": \"0\", **(extra_env or {})},\n        timeout=timeout, check=True,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True)\n    return proc\n",
        "test_name": "test_subprocess_run_helper",
        "test_lineno": 119,
        "test_code": "def test_subprocess_run_helper():\n    \"\"\"Check the correctness of subprocess_run_helper\n    \"\"\"\n    assert subprocess_run_helper(lambda: 1 + 1, \"1\", \"2\").stdout == b\"3\"",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_6.py",
        "name": "_resolve_string",
        "docstring": "Get the value from environment given a matcher containing a name and an optional default value.\nIf the variable is not defined in environment and no default value is provided, an Error is raised.",
        "lineno": 7,
        "code": "def _resolve_string(matcher):\n    '''\n    Get the value from environment given a matcher containing a name and an optional default value.\n    If the variable is not defined in environment and no default value is provided, an Error is raised.\n    '''\n    name, default = matcher.group(\"name\"), matcher.group(\"default\")\n    out = os.getenv(name, default=default)\n    if out is None:\n        raise ValueError(\"Cannot find variable ${name} in envivonment\".format(name=name))\n    return out\n",
        "test_name": "test__resolve_string",
        "test_lineno": 21,
        "test_code": "def test__resolve_string():\n    \"\"\"Check the correctness of _resolve_string\n    \"\"\"\n    assert _resolve_string(re.compile(r\"\\$\\{(?P<name>[a-zA-Z0-9_]+)(?P<default>\\:.+)?\\}\").match(\"${name}\")) == \"name\"",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_2.py",
        "name": "_parse_image_ref",
        "docstring": "Parse an image href into composite parts.\n\n:param image_href: href of an image\n:returns: a tuple of the form (image_id, netloc, use_ssl)\n:raises ValueError:",
        "lineno": 34,
        "code": "def _parse_image_ref(image_href: str) -> Tuple[str, str, bool]:\n    \"\"\"Parse an image href into composite parts.\n\n    :param image_href: href of an image\n    :returns: a tuple of the form (image_id, netloc, use_ssl)\n    :raises ValueError:\n\n    \"\"\"\n    url = urllib.parse.urlparse(image_href)\n    netloc = url.netloc\n    image_id = url.path.split('/')[-1]\n    use_ssl = (url.scheme == 'https')\n    return (image_id, netloc, use_ssl)\n",
        "test_name": "test__parse_image_ref",
        "test_lineno": 51,
        "test_code": "def test__parse_image_ref():\n    \"\"\"Check the correctness of _parse_image_ref\n    \"\"\"\n    assert _parse_image_ref('http://example.com/image_id') == ('image_id', 'example.com', False)\n    assert _parse_image_ref('https://example.com/image_id') == ('image_id', 'example.com', True)\n    assert _parse_image_ref('https://example.com/image_id.tar.gz') == ('image_id.tar.gz', 'example.com', True)\n    assert _parse_image_ref('https://example.com/image_id.tar.gz.gz') == ('image_id.tar.gz.gz', 'example.com', True)\n    assert _parse_image_ref('https://example.com/image_id.tar.gz.gz.gz') == ('image_id.tar.gz.gz.gz', 'example.com', True)\n",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_13.py",
        "name": "remove_ending_os_sep",
        "docstring": "Iterate over a string list and remove trailing os seperator characters.\n\nEach string is tested if its length is greater than one and if the last\ncharacter is the pathname seperator. If so, the pathname seperator character\nis removed.\n\nArgs:\n    input_list: list of strings\n\nReturns:\n    Processed list of strings\n\nRaises:\n    TypeError",
        "lineno": 19,
        "code": "def remove_ending_os_sep(input_list):\n    \"\"\"\n    Iterate over a string list and remove trailing os seperator characters.\n\n    Each string is tested if its length is greater than one and if the last\n    character is the pathname seperator. If so, the pathname seperator character\n    is removed.\n\n    Args:\n        input_list: list of strings\n\n    Returns:\n        Processed list of strings\n\n    Raises:\n        TypeError\n    \"\"\"\n\n    # Input could be None, so test for that case\n    if input_list is None:\n        return []\n\n    return [item[:-1] if len(item) >= 2 and item.endswith(os.sep)\n            else item for item in input_list]\n",
        "test_name": "test_remove_ending_os_sep",
        "test_lineno": 48,
        "test_code": "def test_remove_ending_os_sep():\n    \"\"\"Check the correctness of remove_ending_os_sep\n    \"\"\"\n    assert remove_ending_os_sep(['a', 'b', 'c']) == ['a', 'b', 'c']\n    assert remove_ending_os_sep(['a', 'b', 'c' + os.sep]) == ['a', 'b', 'c']\n    assert remove_ending_os_sep(['a', 'b', 'c' + os.sep * 2]) == ['a', 'b', 'c' + os.sep]\n    assert remove_ending_os_sep(['a', 'b', 'c' + os.sep * 3]) == ['a', 'b', 'c' + os.sep * 2]",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_23.py",
        "name": "gaussian",
        "docstring": "Gaussian centered around 0.2 with a sigma of 0.1.",
        "lineno": 4,
        "code": "def gaussian(x):\n        \"\"\"\n        Gaussian centered around 0.2 with a sigma of 0.1.\n        \"\"\"\n        mu = 0.2\n        sigma = 0.1\n        return np.exp(-(x-mu)**2/sigma**2)\n",
        "test_name": "test_gaussian",
        "test_lineno": 12,
        "test_code": "def test_gaussian():\n    \"\"\"Check the correctness of gaussian\n    \"\"\"\n    assert gaussian(0) == np.exp(-(0-0.2)**2/0.1**2)\n    assert gaussian(1) == np.exp(-(1-0.2)**2/0.1**2)\n    assert gaussian(2) == np.exp(-(2-0.2)**2/0.1**2)\n    assert gaussian(3) == np.exp(-(3-0.2)**2/0.1**2)\n    assert gaussian(4) == np.exp(-(4-0.2)**2/0.1**2)",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_17.py",
        "name": "get_pattern",
        "docstring": "This method converts the given string to regex pattern",
        "lineno": 10,
        "code": "def get_pattern(pattern, strip=True):\n    \"\"\"\n    This method converts the given string to regex pattern\n    \"\"\"\n    if type(pattern) == re.Pattern:\n        return pattern\n\n    if strip and type(pattern) == str:\n        pattern = pattern.strip()\n\n    return re.compile(pattern)\n",
        "test_name": "test_get_pattern",
        "test_lineno": 24,
        "test_code": "def test_get_pattern():\n    \"\"\"Check the correctness of get_pattern\n    \"\"\"\n    assert get_pattern('1.cpp',) == re.compile('1.cpp')\n    assert get_pattern('4.cpp') == re.compile('4.cpp')\n    assert get_pattern('9.h') == re.compile('9.h')",
        "level": "slib_runnable"
    },
    {
        "file_path": "slib_runnable/test_7.py",
        "name": "run_command",
        "docstring": "Call the given command(s).",
        "lineno": 73,
        "code": "def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):\n    \"\"\"Call the given command(s).\"\"\"\n    assert isinstance(commands, list)\n    process = None\n\n    popen_kwargs = {}\n    if sys.platform == \"win32\":\n        # This hides the console window if pythonw.exe is used\n        startupinfo = subprocess.STARTUPINFO()\n        startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        popen_kwargs[\"startupinfo\"] = startupinfo\n\n    for command in commands:\n        try:\n            dispcmd = str([command] + args)\n            # remember shell=False, so use git.cmd on windows, not just git\n            process = subprocess.Popen(\n                [command] + args,\n                cwd=cwd,\n                env=env,\n                stdout=subprocess.PIPE,\n                stderr=(subprocess.PIPE if hide_stderr else None),\n                **popen_kwargs\n            )\n            break\n        except OSError:\n            e = sys.exc_info()[1]\n            if e.errno == errno.ENOENT:\n                continue\n            if verbose:\n                print(\"unable to run %s\" % dispcmd)\n                print(e)\n            return None, None\n    else:\n        if verbose:\n            print(\"unable to find command, tried %s\" % (commands,))\n        return None, None\n    stdout = process.communicate()[0].strip().decode()\n    if process.returncode != 0:\n        if verbose:\n            print(\"unable to run %s (error)\" % dispcmd)\n            print(\"stdout was %s\" % stdout)\n        return None, process.returncode\n    return stdout, process.returncode\n",
        "test_name": "test_run_command",
        "test_lineno": 690,
        "test_code": "def test_run_command():\n    \"\"\"Check the correctness of run_command\n    \"\"\"\n    assert run_command([\"echo\"], [\"hello\"]) == ('hello', 0)\n    assert run_command([\"echo\"], [\"hello\", \"world\"]) == ('hello world', 0)\n    assert run_command([\"echo\"], [\"hello\", \"world\",'hhh']) == ('hello world hhh', 0)\n    assert run_command([\"echo\"], [\"hello\", \"world\",'111']) == ('hello world 111', 0)",
        "level": "slib_runnable"
    }
]